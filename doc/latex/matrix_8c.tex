\section{src/utils/matrix.c File Reference}
\label{matrix_8c}\index{src/utils/matrix.\+c@{src/utils/matrix.\+c}}


Matrix implement.  


{\ttfamily \#include \char`\"{}matrix.\+h\char`\"{}}\newline
Include dependency graph for matrix.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{matrix_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ matrix} $\ast$ \textbf{ matrix\+\_\+create} (size\+\_\+t rows, size\+\_\+t cols)
\item 
struct \textbf{ matrix} $\ast$ \textbf{ matrix\+\_\+create\+\_\+from\+\_\+array} (size\+\_\+t rows, size\+\_\+t cols, const double values[$\,$])
\item 
void \textbf{ matrix\+\_\+free} (struct \textbf{ matrix} $\ast$mx)
\item 
size\+\_\+t \textbf{ matrix\+\_\+rows} (const struct \textbf{ matrix} $\ast$mx)
\item 
size\+\_\+t \textbf{ matrix\+\_\+cols} (const struct \textbf{ matrix} $\ast$mx)
\item 
double \textbf{ matrix\+\_\+at} (const struct \textbf{ matrix} $\ast$mx, size\+\_\+t rows, size\+\_\+t cols)
\item 
void \textbf{ matrix\+\_\+set} (struct \textbf{ matrix} $\ast$mx, size\+\_\+t rows, size\+\_\+t cols, double value)
\item 
struct \textbf{ matrix} $\ast$ \textbf{ matrix\+\_\+copy} (const struct \textbf{ matrix} $\ast$mx)
\item 
void \textbf{ matrix\+\_\+transpose} (const struct \textbf{ matrix} $\ast$mx, struct \textbf{ matrix} $\ast$tmx)
\item 
void \textbf{ matrix\+\_\+sum} (const struct \textbf{ matrix} $\ast$mx1, const struct \textbf{ matrix} $\ast$mx2, struct \textbf{ matrix} $\ast$sum)
\item 
void \textbf{ matrix\+\_\+hadamard\+\_\+product} (const struct \textbf{ matrix} $\ast$mx1, const struct \textbf{ matrix} $\ast$mx2, struct \textbf{ matrix} $\ast$prod)
\item 
void \textbf{ matrix\+\_\+product} (const struct \textbf{ matrix} $\ast$mx1, const struct \textbf{ matrix} $\ast$mx2, struct \textbf{ matrix} $\ast$prod)
\item 
void \textbf{ matrix\+\_\+scale} (const struct \textbf{ matrix} $\ast$mx, double scale, struct \textbf{ matrix} $\ast$smx)
\item 
double \textbf{ matrix\+\_\+dot\+\_\+product} (const struct \textbf{ matrix} $\ast$v1, const struct \textbf{ matrix} $\ast$v2)
\item 
void \textbf{ matrix\+\_\+identity} (struct \textbf{ matrix} $\ast$mx)
\item 
int \textbf{ matrix\+\_\+is\+\_\+square} (const struct \textbf{ matrix} $\ast$mx)
\item 
int \textbf{ matrix\+\_\+is\+\_\+diagonal} (const struct \textbf{ matrix} $\ast$mx)
\item 
int \textbf{ matrix\+\_\+is\+\_\+upper\+\_\+triangulared} (const struct \textbf{ matrix} $\ast$mx)
\item 
void \textbf{ matrix\+\_\+diagonal} (const struct \textbf{ matrix} $\ast$v, struct \textbf{ matrix} $\ast$mx)
\item 
void \textbf{ matrix\+\_\+print} (const struct \textbf{ matrix} $\ast$mx)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Matrix implement. 

\begin{DoxyAuthor}{Author}
S4\+Master\+Race 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}


\subsection{Function Documentation}
\mbox{\label{matrix_8c_ace105cd24473b52d67874132e81dd55b}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+at@{matrix\+\_\+at}}
\index{matrix\+\_\+at@{matrix\+\_\+at}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+at()}
{\footnotesize\ttfamily double matrix\+\_\+at (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx,  }\item[{size\+\_\+t}]{rows,  }\item[{size\+\_\+t}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get value at {\ttfamily rows} rows and {\ttfamily cols} columns of {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
{\em rows} & rows \\
\hline
{\em cols} & columns \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value at {\ttfamily rows} rows and {\ttfamily cols} columns of {\ttfamily mx}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily rows} must be between {\ttfamily [0, matrix\+\_\+rows(mx)[} 

{\ttfamily cols} must be between {\ttfamily [0, matrix\+\_\+cols(mx)[}
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a70ad38f54a8deaac09ddd554fa0ecccf}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+cols@{matrix\+\_\+cols}}
\index{matrix\+\_\+cols@{matrix\+\_\+cols}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+cols()}
{\footnotesize\ttfamily size\+\_\+t matrix\+\_\+cols (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of columns of {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of columns {\ttfamily mx}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a6663b065febb290385857b26fdb1a353}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+copy@{matrix\+\_\+copy}}
\index{matrix\+\_\+copy@{matrix\+\_\+copy}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+copy()}
{\footnotesize\ttfamily struct \textbf{ matrix}$\ast$ matrix\+\_\+copy (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})}

Copy the matrix {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the copy of {\ttfamily mx}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_ad2d40d9c13eba774d6bb788021242a95}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+create@{matrix\+\_\+create}}
\index{matrix\+\_\+create@{matrix\+\_\+create}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+create()}
{\footnotesize\ttfamily struct \textbf{ matrix}$\ast$ matrix\+\_\+create (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{rows,  }\item[{size\+\_\+t}]{cols }\end{DoxyParamCaption})}

Create a matrix of size {\ttfamily rows} rows and {\ttfamily cols} columns


\begin{DoxyParams}{Parameters}
{\em rows} & number of rows \\
\hline
{\em cols} & number of columns\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the initialized matrix of size {\ttfamily rows} rows and {\ttfamily cols} columns
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily rows} must be greater than zero 

{\ttfamily cols} must be greater than zero
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a268a5429e2e4bc1664045624a82bc09c}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+create\+\_\+from\+\_\+array@{matrix\+\_\+create\+\_\+from\+\_\+array}}
\index{matrix\+\_\+create\+\_\+from\+\_\+array@{matrix\+\_\+create\+\_\+from\+\_\+array}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+create\+\_\+from\+\_\+array()}
{\footnotesize\ttfamily struct \textbf{ matrix}$\ast$ matrix\+\_\+create\+\_\+from\+\_\+array (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{rows,  }\item[{size\+\_\+t}]{cols,  }\item[{const double}]{values[$\,$] }\end{DoxyParamCaption})}

Create a matrix of size {\ttfamily rows} rows and {\ttfamily cols} columns from {\ttfamily values}


\begin{DoxyParams}{Parameters}
{\em rows} & number of rows \\
\hline
{\em cols} & number of columns \\
\hline
{\em values} & an array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the initialized matrix of size {\ttfamily rows} rows and {\ttfamily cols} columns from {\ttfamily values}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily rows} must be greater than zero 

{\ttfamily cols} must be greater than zero 

{\ttfamily values} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a74c9bd4f933938a77a0b30ef3204ab09}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+diagonal@{matrix\+\_\+diagonal}}
\index{matrix\+\_\+diagonal@{matrix\+\_\+diagonal}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+diagonal()}
{\footnotesize\ttfamily void matrix\+\_\+diagonal (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{v,  }\item[{struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})}

Take a vector {\ttfamily v} and put it to the diagonal of {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em v} & a vector \\
\hline
{\em mx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily v} must be not N\+U\+LL 

{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+cols(v)} must be equal to one 

{\ttfamily matrix\+\_\+rows(v)} must be equel to {\ttfamily matrix\+\_\+rows(mx)} 

{\ttfamily matrix\+\_\+rows(mx)} must be equel to {\ttfamily matrix\+\_\+cols(mx)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The diagonal of {\ttfamily mx} is {\ttfamily v} 
\end{DoxyPostcond}
\mbox{\label{matrix_8c_a7ba7365201acc5889936e1836d14cc8b}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+dot\+\_\+product@{matrix\+\_\+dot\+\_\+product}}
\index{matrix\+\_\+dot\+\_\+product@{matrix\+\_\+dot\+\_\+product}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+dot\+\_\+product()}
{\footnotesize\ttfamily double matrix\+\_\+dot\+\_\+product (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{v1,  }\item[{const struct \textbf{ matrix} $\ast$}]{v2 }\end{DoxyParamCaption})}

Do the dot product of vector {\ttfamily v1} with vector {\ttfamily v2}


\begin{DoxyParams}{Parameters}
{\em v1} & a vector \\
\hline
{\em v2} & a vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the dot product of vector {\ttfamily v1} with vector {\ttfamily v2}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily v1} must be not N\+U\+LL 

{\ttfamily v2} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+cols(v1)} and {\ttfamily matrix\+\_\+cols(v2)} must be equal to one 

{\ttfamily matrix\+\_\+rows(v1)} must be equal to {\ttfamily matrix\+\_\+rows(v2)}
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_ac19cd61ef9f183a9b92d6789399f8646}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+free@{matrix\+\_\+free}}
\index{matrix\+\_\+free@{matrix\+\_\+free}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+free()}
{\footnotesize\ttfamily void matrix\+\_\+free (\begin{DoxyParamCaption}\item[{struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Free the matrix {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily mx} is freed
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a52deb76b55ddbb957264866f5c856d0a}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+hadamard\+\_\+product@{matrix\+\_\+hadamard\+\_\+product}}
\index{matrix\+\_\+hadamard\+\_\+product@{matrix\+\_\+hadamard\+\_\+product}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+hadamard\+\_\+product()}
{\footnotesize\ttfamily void matrix\+\_\+hadamard\+\_\+product (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx1,  }\item[{const struct \textbf{ matrix} $\ast$}]{mx2,  }\item[{struct \textbf{ matrix} $\ast$}]{prod }\end{DoxyParamCaption})}

Do the hadamard product of matrix {\ttfamily mx1} with {\ttfamily mx2}


\begin{DoxyParams}{Parameters}
{\em mx1} & a matrix \\
\hline
{\em mx2} & a matrix \\
\hline
{\em prod} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx1} must be not N\+U\+LL 

{\ttfamily mx2} must be not N\+U\+LL 

{\ttfamily prod} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+rows(mx1)} must be equal to {\ttfamily matrix\+\_\+rows(mx2)} 

{\ttfamily matrix\+\_\+cols(mx1)} must be equal to {\ttfamily matrix\+\_\+cols(mx2)} 

{\ttfamily matrix\+\_\+rows(prod)} must be equal to {\ttfamily matrix\+\_\+rows(mx1)} 

{\ttfamily matrix\+\_\+cols(prod)} must be equal to {\ttfamily matrix\+\_\+cols(mx1)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily prod} is the hadamard product of matrix {\ttfamily mx1} with {\ttfamily mx2}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_afa54c9d6ef22a1e0a0ca39221939b8c7}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+identity@{matrix\+\_\+identity}}
\index{matrix\+\_\+identity@{matrix\+\_\+identity}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+identity()}
{\footnotesize\ttfamily void matrix\+\_\+identity (\begin{DoxyParamCaption}\item[{struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})}

Set the matrix {\ttfamily mx} to an identity matrix


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+rows(mx)} must be equal to {\ttfamily matrix\+\_\+cols(mx)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily mx} is an identity matrix
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a2379a87492cbb3bf0c4fdc8e58589d1c}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+is\+\_\+diagonal@{matrix\+\_\+is\+\_\+diagonal}}
\index{matrix\+\_\+is\+\_\+diagonal@{matrix\+\_\+is\+\_\+diagonal}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+is\+\_\+diagonal()}
{\footnotesize\ttfamily int matrix\+\_\+is\+\_\+diagonal (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Check if the matrix {\ttfamily mx} is diagonaled


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily 1} if the matrix is diagonaled, {\ttfamily 0} otherwise
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a0bc537e836547fd549f64464c938b1d2}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+is\+\_\+square@{matrix\+\_\+is\+\_\+square}}
\index{matrix\+\_\+is\+\_\+square@{matrix\+\_\+is\+\_\+square}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+is\+\_\+square()}
{\footnotesize\ttfamily int matrix\+\_\+is\+\_\+square (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Check if the matrix {\ttfamily mx} is squared


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily 1} if the matrix is squared, {\ttfamily 0} otherwise
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_ae3a4575aa2b0493bbf0b7bee70d30f07}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+is\+\_\+upper\+\_\+triangulared@{matrix\+\_\+is\+\_\+upper\+\_\+triangulared}}
\index{matrix\+\_\+is\+\_\+upper\+\_\+triangulared@{matrix\+\_\+is\+\_\+upper\+\_\+triangulared}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+is\+\_\+upper\+\_\+triangulared()}
{\footnotesize\ttfamily int matrix\+\_\+is\+\_\+upper\+\_\+triangulared (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Check if the matrix {\ttfamily mx} is upper triangulared


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily 1} if the matrix is upper triangulared, {\ttfamily 0} otherwise
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a41f40f546c465fd096679a7f94ea5e8b}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+print@{matrix\+\_\+print}}
\index{matrix\+\_\+print@{matrix\+\_\+print}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+print()}
{\footnotesize\ttfamily void matrix\+\_\+print (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})}

Print the matrix {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Print the matrix {\ttfamily mx} 
\end{DoxyPostcond}
\mbox{\label{matrix_8c_a48e828fb00afc50e3616adefe87643bf}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+product@{matrix\+\_\+product}}
\index{matrix\+\_\+product@{matrix\+\_\+product}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+product()}
{\footnotesize\ttfamily void matrix\+\_\+product (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx1,  }\item[{const struct \textbf{ matrix} $\ast$}]{mx2,  }\item[{struct \textbf{ matrix} $\ast$}]{prod }\end{DoxyParamCaption})}

Multiply the matrix {\ttfamily mx1} with {\ttfamily mx2}


\begin{DoxyParams}{Parameters}
{\em mx1} & a matrix \\
\hline
{\em mx2} & a matrix \\
\hline
{\em prod} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx1} must be not N\+U\+LL 

{\ttfamily mx2} must be not N\+U\+LL 

{\ttfamily prod} must be not N\+U\+LL 

{\ttfamily prod} must be not equal to {\ttfamily mx1} 

{\ttfamily prod} must be not equal to {\ttfamily mx2} 

{\ttfamily matrix\+\_\+cols(mx1)} must be equal to {\ttfamily matrix\+\_\+rows(mx2)} 

{\ttfamily matrix\+\_\+rows(prod)} must be equal to {\ttfamily matrix\+\_\+rows(mx1)} 

{\ttfamily matrix\+\_\+cols(prod)} must be equal to {\ttfamily matrix\+\_\+cols(mx2)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily prod} is the product of {\ttfamily mx1} with {\ttfamily mx2}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(nmp) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a7d9ca687a57f2328a02b9a056964b2fb}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+rows@{matrix\+\_\+rows}}
\index{matrix\+\_\+rows@{matrix\+\_\+rows}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+rows()}
{\footnotesize\ttfamily size\+\_\+t matrix\+\_\+rows (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of rows {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of rows of {\ttfamily mx}
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_aed3de5b6889de7358d66e2ac1b4c6efb}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+scale@{matrix\+\_\+scale}}
\index{matrix\+\_\+scale@{matrix\+\_\+scale}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+scale()}
{\footnotesize\ttfamily void matrix\+\_\+scale (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx,  }\item[{double}]{scale,  }\item[{struct \textbf{ matrix} $\ast$}]{smx }\end{DoxyParamCaption})}

Scale the matrix {\ttfamily mx} with {\ttfamily scale}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
{\em scale} & the scale factor \\
\hline
{\em smx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily smx} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+rows(smx)} must be equal to {\ttfamily matrix\+\_\+rows(mx)} 

{\ttfamily matrix\+\_\+cols(smx)} must be equal to {\ttfamily matrix\+\_\+cols(mx)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily smx} is the {\ttfamily scale} scaled matrix of {\ttfamily mx}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a9e159c4c2c953106b7a1a4f0d4a03616}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+set@{matrix\+\_\+set}}
\index{matrix\+\_\+set@{matrix\+\_\+set}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+set()}
{\footnotesize\ttfamily void matrix\+\_\+set (\begin{DoxyParamCaption}\item[{struct \textbf{ matrix} $\ast$}]{mx,  }\item[{size\+\_\+t}]{rows,  }\item[{size\+\_\+t}]{cols,  }\item[{double}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set the value at {\ttfamily rows} rows and {\ttfamily cols} columns with {\ttfamily value} of {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
{\em rows} & rows \\
\hline
{\em cols} & columns \\
\hline
{\em value} & a value\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily rows} must be between {\ttfamily [0, matrix\+\_\+rows(mx)[} 

{\ttfamily cols} must be between {\ttfamily [0, matrix\+\_\+cols(mx)[}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
the value at {\ttfamily rows} rows and {\ttfamily cols} columns is {\ttfamily value}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_a4a7c4970506bd591d265596d41c7fa0f}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+sum@{matrix\+\_\+sum}}
\index{matrix\+\_\+sum@{matrix\+\_\+sum}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+sum()}
{\footnotesize\ttfamily void matrix\+\_\+sum (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx1,  }\item[{const struct \textbf{ matrix} $\ast$}]{mx2,  }\item[{struct \textbf{ matrix} $\ast$}]{sum }\end{DoxyParamCaption})}

Sum the matrix {\ttfamily mx1} with {\ttfamily mx2}


\begin{DoxyParams}{Parameters}
{\em mx1} & a matrix \\
\hline
{\em mx2} & a matrix \\
\hline
{\em sum} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx1} must be not N\+U\+LL 

{\ttfamily mx2} must be not N\+U\+LL 

{\ttfamily sum} must be not N\+U\+LL 

{\ttfamily matrix\+\_\+rows(mx1)} must be equal to {\ttfamily matrix\+\_\+rows(mx2)} 

{\ttfamily matrix\+\_\+cols(mx1)} must be equal to {\ttfamily matrix\+\_\+cols(mx2)} 

{\ttfamily matrix\+\_\+rows(sum)} must be equal to {\ttfamily matrix\+\_\+rows(mx1)} 

{\ttfamily matrix\+\_\+cols(sum)} must be equal to {\ttfamily matrix\+\_\+cols(mx1)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily sum} is the sum of matrix {\ttfamily mx1} with {\ttfamily mx2}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{matrix_8c_ace9535ebf3fa66aa5aeed040eeccc1b3}} 
\index{matrix.\+c@{matrix.\+c}!matrix\+\_\+transpose@{matrix\+\_\+transpose}}
\index{matrix\+\_\+transpose@{matrix\+\_\+transpose}!matrix.\+c@{matrix.\+c}}
\subsubsection{matrix\+\_\+transpose()}
{\footnotesize\ttfamily void matrix\+\_\+transpose (\begin{DoxyParamCaption}\item[{const struct \textbf{ matrix} $\ast$}]{mx,  }\item[{struct \textbf{ matrix} $\ast$}]{tmx }\end{DoxyParamCaption})}

Transpose the matrix {\ttfamily mx}


\begin{DoxyParams}{Parameters}
{\em mx} & a matrix \\
\hline
{\em tmx} & a matrix\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily mx} must be not N\+U\+LL 

{\ttfamily tmx} must be not N\+U\+LL 

{\ttfamily tmx} must be not equal to {\ttfamily mx} 

{\ttfamily matrix\+\_\+rows(tmx)} must be equal to {\ttfamily matrix\+\_\+cols(mx)} 

{\ttfamily matrix\+\_\+cols(tmx)} must be equal to {\ttfamily matrix\+\_\+rows(mx)}
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily tmx} is the transposed matrix of {\ttfamily mx}
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
