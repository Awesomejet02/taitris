\section{src/utils/list.h File Reference}
\label{list_8h}\index{src/utils/list.\+h@{src/utils/list.\+h}}


Intrusive list implement.  


{\ttfamily \#include $<$stddef.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
Include dependency graph for list.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=334pt]{list_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=155pt]{list_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ list}
\item 
struct \textbf{ list\+\_\+node}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ list\+\_\+elt}(node,  type,  fieldname)~((type$\ast$)((char$\ast$)(node) -\/ offsetof(type, fieldname)))
\item 
\#define \textbf{ list\+\_\+foreach}(\textbf{ list},  curr)~for (curr = \textbf{ list\+\_\+first}(\textbf{ list}); curr != N\+U\+LL; curr = \textbf{ list\+\_\+next}(curr))
\item 
\#define \textbf{ list\+\_\+foreach\+\_\+elt}(\textbf{ list},  curr,  type,  fieldname)
\item 
\#define \textbf{ list\+\_\+foreach\+\_\+safe}(\textbf{ list},  curr,  tmp)
\item 
\#define \textbf{ list\+\_\+foreach\+\_\+elt\+\_\+safe}(\textbf{ list},  curr,  tmp,  type,  fieldname)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ list\+\_\+init} (struct \textbf{ list} $\ast$\textbf{ list})
\item 
size\+\_\+t \textbf{ list\+\_\+length} (const struct \textbf{ list} $\ast$\textbf{ list})
\item 
struct \textbf{ list\+\_\+node} $\ast$ \textbf{ list\+\_\+first} (const struct \textbf{ list} $\ast$\textbf{ list})
\item 
struct \textbf{ list\+\_\+node} $\ast$ \textbf{ list\+\_\+last} (const struct \textbf{ list} $\ast$\textbf{ list})
\item 
struct \textbf{ list\+\_\+node} $\ast$ \textbf{ list\+\_\+next} (const struct \textbf{ list\+\_\+node} $\ast$node)
\item 
struct \textbf{ list\+\_\+node} $\ast$ \textbf{ list\+\_\+advance} (struct \textbf{ list\+\_\+node} $\ast$node, size\+\_\+t distance)
\item 
struct \textbf{ list\+\_\+node} $\ast$ \textbf{ list\+\_\+at} (const struct \textbf{ list} $\ast$\textbf{ list}, size\+\_\+t pos)
\item 
void \textbf{ list\+\_\+reverse} (struct \textbf{ list} $\ast$\textbf{ list})
\item 
void \textbf{ list\+\_\+swap} (struct \textbf{ list} $\ast$l1, struct \textbf{ list} $\ast$l2)
\item 
void \textbf{ list\+\_\+split\+\_\+at} (struct \textbf{ list} $\ast$\textbf{ list}, size\+\_\+t pos, struct \textbf{ list} $\ast$right)
\item 
void \textbf{ list\+\_\+concat} (struct \textbf{ list} $\ast$l1, struct \textbf{ list} $\ast$l2)
\item 
void \textbf{ list\+\_\+sort} (struct \textbf{ list} $\ast$\textbf{ list}, int($\ast$cmp)(struct \textbf{ list\+\_\+node} $\ast$, struct \textbf{ list\+\_\+node} $\ast$))
\item 
int \textbf{ list\+\_\+is\+\_\+empty} (const struct \textbf{ list} $\ast$\textbf{ list})
\item 
void \textbf{ list\+\_\+add} (struct \textbf{ list} $\ast$\textbf{ list}, struct \textbf{ list\+\_\+node} $\ast$node)
\item 
void \textbf{ list\+\_\+append} (struct \textbf{ list} $\ast$\textbf{ list}, struct \textbf{ list\+\_\+node} $\ast$node)
\item 
void \textbf{ list\+\_\+insert\+\_\+after} (struct \textbf{ list} $\ast$\textbf{ list}, struct \textbf{ list\+\_\+node} $\ast$curr, struct \textbf{ list\+\_\+node} $\ast$node)
\item 
void \textbf{ list\+\_\+insert\+\_\+at} (struct \textbf{ list} $\ast$\textbf{ list}, struct \textbf{ list\+\_\+node} $\ast$node, size\+\_\+t pos)
\item 
void \textbf{ list\+\_\+del} (struct \textbf{ list} $\ast$\textbf{ list})
\item 
void \textbf{ list\+\_\+del\+\_\+after} (struct \textbf{ list} $\ast$\textbf{ list}, struct \textbf{ list\+\_\+node} $\ast$node)
\item 
void \textbf{ list\+\_\+del\+\_\+at} (struct \textbf{ list} $\ast$\textbf{ list}, size\+\_\+t pos)
\item 
void \textbf{ list\+\_\+print} (const struct \textbf{ list} $\ast$\textbf{ list})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Intrusive list implement. 

\begin{DoxyAuthor}{Author}
S4\+Master\+Race 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}


\subsection{Macro Definition Documentation}
\mbox{\label{list_8h_a12e153fb4ee7d1a550fa57a733629eac}} 
\index{list.\+h@{list.\+h}!list\+\_\+elt@{list\+\_\+elt}}
\index{list\+\_\+elt@{list\+\_\+elt}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+elt}
{\footnotesize\ttfamily \#define list\+\_\+elt(\begin{DoxyParamCaption}\item[{}]{node,  }\item[{}]{type,  }\item[{}]{fieldname }\end{DoxyParamCaption})~((type$\ast$)((char$\ast$)(node) -\/ offsetof(type, fieldname)))}

Returns a pointer to the structure which contains the node.


\begin{DoxyParams}{Parameters}
{\em node} & a list node (struct list\+\_\+node$\ast$). \\
\hline
{\em type} & type of the structure which contains the node. \\
\hline
{\em fieldname} & name of the node (field name) in the structure.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a4cbdb4dde9bd442caf5bca5a01b891af}} 
\index{list.\+h@{list.\+h}!list\+\_\+foreach@{list\+\_\+foreach}}
\index{list\+\_\+foreach@{list\+\_\+foreach}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+foreach}
{\footnotesize\ttfamily \#define list\+\_\+foreach(\begin{DoxyParamCaption}\item[{}]{\textbf{ list},  }\item[{}]{curr }\end{DoxyParamCaption})~for (curr = \textbf{ list\+\_\+first}(\textbf{ list}); curr != N\+U\+LL; curr = \textbf{ list\+\_\+next}(curr))}

Iterates over list (nodes). 
\begin{DoxyParams}{Parameters}
{\em list} & a list (struct list$\ast$). \\
\hline
{\em curr} & a struct list\+\_\+node$\ast$ used to hold the current element.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily curr} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a007b1aa63bb2db9f0dc5e7947fb28ee9}} 
\index{list.\+h@{list.\+h}!list\+\_\+foreach\+\_\+elt@{list\+\_\+foreach\+\_\+elt}}
\index{list\+\_\+foreach\+\_\+elt@{list\+\_\+foreach\+\_\+elt}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+foreach\+\_\+elt}
{\footnotesize\ttfamily \#define list\+\_\+foreach\+\_\+elt(\begin{DoxyParamCaption}\item[{}]{\textbf{ list},  }\item[{}]{curr,  }\item[{}]{type,  }\item[{}]{fieldname }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{for} (curr = list_elt(list_first(list), type, fieldname);       \(\backslash\)
         curr != NULL;                           \(\backslash\)
         curr = curr->fieldname.next == NULL ? NULL :           \(\backslash\)
         list\_elt(list_next(&(curr->fieldname)), type, fieldname))
\end{DoxyCode}
Iterates over list (elements) 
\begin{DoxyParams}{Parameters}
{\em list} & a list (struct list$\ast$). \\
\hline
{\em curr} & pointer (type$\ast$) used to hold the current element. \\
\hline
{\em type} & type of the structure which contains the node. \\
\hline
{\em fieldname} & name of the node (field name) in the structure.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty. 

{\ttfamily curr} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a3ac4de28b3c9c2a36cf360390491afce}} 
\index{list.\+h@{list.\+h}!list\+\_\+foreach\+\_\+elt\+\_\+safe@{list\+\_\+foreach\+\_\+elt\+\_\+safe}}
\index{list\+\_\+foreach\+\_\+elt\+\_\+safe@{list\+\_\+foreach\+\_\+elt\+\_\+safe}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+foreach\+\_\+elt\+\_\+safe}
{\footnotesize\ttfamily \#define list\+\_\+foreach\+\_\+elt\+\_\+safe(\begin{DoxyParamCaption}\item[{}]{\textbf{ list},  }\item[{}]{curr,  }\item[{}]{tmp,  }\item[{}]{type,  }\item[{}]{fieldname }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{for} (curr = list_elt(list_first(list), type, fieldname),      \(\backslash\)
         tmp  = list_next(&(curr->fieldname));              \(\backslash\)
         curr != NULL;                          \(\backslash\)
         curr = tmp == NULL ? NULL : list_elt(tmp, type, fieldname), \(\backslash\)
         tmp  = tmp == NULL ? NULL : list_next(tmp))          \(\backslash\)
\end{DoxyCode}
Iterates over list (elements), allows deletion of the current element. 
\begin{DoxyParams}{Parameters}
{\em list} & a list (struct list$\ast$). \\
\hline
{\em curr} & pointer (type$\ast$) used to hold the current element. \\
\hline
{\em tmp} & a struct list\+\_\+node$\ast$ used as temporary storage. \\
\hline
{\em type} & type of the structure which contains the node. \\
\hline
{\em fieldname} & name of the node (field name) in the structure.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty. 

{\ttfamily curr} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a76d263fd3212139ab16fbd2d1bfd8a43}} 
\index{list.\+h@{list.\+h}!list\+\_\+foreach\+\_\+safe@{list\+\_\+foreach\+\_\+safe}}
\index{list\+\_\+foreach\+\_\+safe@{list\+\_\+foreach\+\_\+safe}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+foreach\+\_\+safe}
{\footnotesize\ttfamily \#define list\+\_\+foreach\+\_\+safe(\begin{DoxyParamCaption}\item[{}]{\textbf{ list},  }\item[{}]{curr,  }\item[{}]{tmp }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{for} (curr = list_first(list), tmp = list_next(curr);    \(\backslash\)
         curr != NULL;                    \(\backslash\)
         curr = tmp, tmp = tmp == NULL ? NULL : list_next(tmp))
\end{DoxyCode}
Iterates over list (nodes), allows deletion of the current node. 
\begin{DoxyParams}{Parameters}
{\em list} & a list (struct list$\ast$). \\
\hline
{\em curr} & a struct list\+\_\+node$\ast$ used to hold the current element. \\
\hline
{\em tmp} & a struct list\+\_\+node$\ast$ used as temporary storage.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily curr} must be not N\+U\+LL. 

{\ttfamily tmp} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}


\subsection{Function Documentation}
\mbox{\label{list_8h_a9a78b4aa6e818c4b9e3da16cf3d1e9cf}} 
\index{list.\+h@{list.\+h}!list\+\_\+add@{list\+\_\+add}}
\index{list\+\_\+add@{list\+\_\+add}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+add()}
{\footnotesize\ttfamily void list\+\_\+add (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adds {\ttfamily node} in the front of {\ttfamily list}


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em node} & the new node.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size increases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a3e71507d9a07668a357907d4515336de}} 
\index{list.\+h@{list.\+h}!list\+\_\+advance@{list\+\_\+advance}}
\index{list\+\_\+advance@{list\+\_\+advance}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+advance()}
{\footnotesize\ttfamily struct \textbf{ list\+\_\+node}$\ast$ list\+\_\+advance (\begin{DoxyParamCaption}\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node,  }\item[{size\+\_\+t}]{distance }\end{DoxyParamCaption})}

Returns the nth-\/node after the current one.


\begin{DoxyParams}{Parameters}
{\em node} & a node. \\
\hline
{\em distance} & distance to move on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the nth-\/node after {\ttfamily node}.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(n) 
\end{DoxyRemark}
\mbox{\label{list_8h_a40638777b5f341c88e8b09acf75fb8c9}} 
\index{list.\+h@{list.\+h}!list\+\_\+append@{list\+\_\+append}}
\index{list\+\_\+append@{list\+\_\+append}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+append()}
{\footnotesize\ttfamily void list\+\_\+append (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adds {\ttfamily node} at the end of {\ttfamily list}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em node} & the new node.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size increases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(n) 
\end{DoxyRemark}
\mbox{\label{list_8h_abcf02e7a58093a7b70a84be889da4aad}} 
\index{list.\+h@{list.\+h}!list\+\_\+at@{list\+\_\+at}}
\index{list\+\_\+at@{list\+\_\+at}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+at()}
{\footnotesize\ttfamily struct \textbf{ list\+\_\+node}$\ast$ list\+\_\+at (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list,  }\item[{size\+\_\+t}]{pos }\end{DoxyParamCaption})}

Returns node at the position {\ttfamily pos}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em pos} & position (0-\/based) of the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the node at the position {\ttfamily pos}.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty. 

{\ttfamily pos} must be in [0; list\+\_\+length(list)[.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_af71fffc666f138957b1e015fdae5fe1f}} 
\index{list.\+h@{list.\+h}!list\+\_\+concat@{list\+\_\+concat}}
\index{list\+\_\+concat@{list\+\_\+concat}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+concat()}
{\footnotesize\ttfamily void list\+\_\+concat (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{l1,  }\item[{struct \textbf{ list} $\ast$}]{l2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Concatenates two lists.


\begin{DoxyParams}{Parameters}
{\em l1} & list 1. \\
\hline
{\em l2} & list 2.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily l1} must be not N\+U\+LL. 

{\ttfamily l2} must be not N\+U\+LL. 

{\ttfamily l1} must be different of {\ttfamily l2}.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily l2} is reset to an empty list.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a4ee9116bc5b8f1b5da93f415d8529d58}} 
\index{list.\+h@{list.\+h}!list\+\_\+del@{list\+\_\+del}}
\index{list\+\_\+del@{list\+\_\+del}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+del()}
{\footnotesize\ttfamily void list\+\_\+del (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deletes the first node.


\begin{DoxyParams}{Parameters}
{\em list} & a list.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size decreases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_ad301311c004c0b56091e2e89e5a1f5e8}} 
\index{list.\+h@{list.\+h}!list\+\_\+del\+\_\+after@{list\+\_\+del\+\_\+after}}
\index{list\+\_\+del\+\_\+after@{list\+\_\+del\+\_\+after}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+del\+\_\+after()}
{\footnotesize\ttfamily void list\+\_\+del\+\_\+after (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deletes the node at after the node {\ttfamily curr}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em node} & a node of {\ttfamily list}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily node} must be not N\+U\+LL. 

{\ttfamily list} must be not empty. 

{\ttfamily node} must a node of {\ttfamily list}.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size decreases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a1b32056f04fe6cce76bc8774b462598f}} 
\index{list.\+h@{list.\+h}!list\+\_\+del\+\_\+at@{list\+\_\+del\+\_\+at}}
\index{list\+\_\+del\+\_\+at@{list\+\_\+del\+\_\+at}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+del\+\_\+at()}
{\footnotesize\ttfamily void list\+\_\+del\+\_\+at (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{size\+\_\+t}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deletes the node at the position {\ttfamily pos}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em pos} & index (0-\/based) of the node to delete.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty. 

{\ttfamily pos} must be in [0; list\+\_\+length(list)[.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size decreases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(n) 
\end{DoxyRemark}
\mbox{\label{list_8h_ab31246f096207d08b4756bd2c209fa2b}} 
\index{list.\+h@{list.\+h}!list\+\_\+first@{list\+\_\+first}}
\index{list\+\_\+first@{list\+\_\+first}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+first()}
{\footnotesize\ttfamily struct \textbf{ list\+\_\+node}$\ast$ list\+\_\+first (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})}

Returns the first node.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first node.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily list} must be not empty.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a8aa862d10f52f7b0348fce990c7c12db}} 
\index{list.\+h@{list.\+h}!list\+\_\+init@{list\+\_\+init}}
\index{list\+\_\+init@{list\+\_\+init}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+init()}
{\footnotesize\ttfamily void list\+\_\+init (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initializes the list.


\begin{DoxyParams}{Parameters}
{\em list} & a list.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily list} is empty. 

{\ttfamily list} has a size of 0.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_aac5b9656592776dd99c192c7c8f2b18f}} 
\index{list.\+h@{list.\+h}!list\+\_\+insert\+\_\+after@{list\+\_\+insert\+\_\+after}}
\index{list\+\_\+insert\+\_\+after@{list\+\_\+insert\+\_\+after}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+insert\+\_\+after()}
{\footnotesize\ttfamily void list\+\_\+insert\+\_\+after (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{curr,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Inserts {\ttfamily node} at after the node {\ttfamily curr}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em curr} & a node of {\ttfamily list}. \\
\hline
{\em node} & new node.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily curr} must be not N\+U\+LL. 

{\ttfamily curr} must a node of {\ttfamily list}. 

{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size increases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a7f9a331cc4eab17800dc8fac961b50c9}} 
\index{list.\+h@{list.\+h}!list\+\_\+insert\+\_\+at@{list\+\_\+insert\+\_\+at}}
\index{list\+\_\+insert\+\_\+at@{list\+\_\+insert\+\_\+at}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+insert\+\_\+at()}
{\footnotesize\ttfamily void list\+\_\+insert\+\_\+at (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{struct \textbf{ list\+\_\+node} $\ast$}]{node,  }\item[{size\+\_\+t}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Inserts {\ttfamily node} at the position {\ttfamily pos} in {\ttfamily list}.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
{\em node} & new node. \\
\hline
{\em pos} & position (0-\/based) where to insert the new node.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily node} must be not N\+U\+LL. 

{\ttfamily pos} must be in [0; list\+\_\+length(list)].
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
List size increases by 1.
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(n) 
\end{DoxyRemark}
\mbox{\label{list_8h_aa1c6d252fce51c8ebed845bf8fbcfdb7}} 
\index{list.\+h@{list.\+h}!list\+\_\+is\+\_\+empty@{list\+\_\+is\+\_\+empty}}
\index{list\+\_\+is\+\_\+empty@{list\+\_\+is\+\_\+empty}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+is\+\_\+empty()}
{\footnotesize\ttfamily int list\+\_\+is\+\_\+empty (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Tests if a list is empty.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the list is empty, otherwise 0.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a5a3f95e5d8edeb9ff16d4ce0d0ceac95}} 
\index{list.\+h@{list.\+h}!list\+\_\+last@{list\+\_\+last}}
\index{list\+\_\+last@{list\+\_\+last}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+last()}
{\footnotesize\ttfamily struct \textbf{ list\+\_\+node}$\ast$ list\+\_\+last (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})}

Returns the last node.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the last node.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a5ded68cde03f48a724bb04326dc5cc87}} 
\index{list.\+h@{list.\+h}!list\+\_\+length@{list\+\_\+length}}
\index{list\+\_\+length@{list\+\_\+length}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+length()}
{\footnotesize\ttfamily size\+\_\+t list\+\_\+length (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Returns the size of the list.


\begin{DoxyParams}{Parameters}
{\em list} & a list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the list.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_aa2253e2e4f2da4eb7a3b17759369dcd7}} 
\index{list.\+h@{list.\+h}!list\+\_\+next@{list\+\_\+next}}
\index{list\+\_\+next@{list\+\_\+next}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+next()}
{\footnotesize\ttfamily struct \textbf{ list\+\_\+node}$\ast$ list\+\_\+next (\begin{DoxyParamCaption}\item[{const struct \textbf{ list\+\_\+node} $\ast$}]{node }\end{DoxyParamCaption})}

Returns the next node.


\begin{DoxyParams}{Parameters}
{\em node} & a node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the next node.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
{\ttfamily node} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_a1ac8fe6b1cacad62605ae8b38a6a25d3}} 
\index{list.\+h@{list.\+h}!list\+\_\+print@{list\+\_\+print}}
\index{list\+\_\+print@{list\+\_\+print}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+print()}
{\footnotesize\ttfamily void list\+\_\+print (\begin{DoxyParamCaption}\item[{const struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})}

Print the list


\begin{DoxyParams}{Parameters}
{\em list} & a list \\
\hline
\end{DoxyParams}
\mbox{\label{list_8h_ac2bed4543182c599319388b26e10811f}} 
\index{list.\+h@{list.\+h}!list\+\_\+reverse@{list\+\_\+reverse}}
\index{list\+\_\+reverse@{list\+\_\+reverse}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+reverse()}
{\footnotesize\ttfamily void list\+\_\+reverse (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Reverses the order of the elements in the list.


\begin{DoxyParams}{Parameters}
{\em list} & a list.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_aafd30da5da0e55fa5510328f579e7830}} 
\index{list.\+h@{list.\+h}!list\+\_\+sort@{list\+\_\+sort}}
\index{list\+\_\+sort@{list\+\_\+sort}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+sort()}
{\footnotesize\ttfamily void list\+\_\+sort (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{int($\ast$)(struct \textbf{ list\+\_\+node} $\ast$, struct \textbf{ list\+\_\+node} $\ast$)}]{cmp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sort a list using a comparison function.

The contents of the list are sorted in ascending order according to a comparison function which is called with two arguments that point to the node being compared.

The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.

If two members compare as equal, their order in the sorted list is preserved.


\begin{DoxyParams}{Parameters}
{\em list} & list to sort. \\
\hline
{\em cmp} & comparison function to use.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily cmp} must be not N\+U\+LL.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
The sort is stable. 

Complexity\+: O(\+N log N) 

Space complexity\+: O(1) 
\end{DoxyRemark}
\mbox{\label{list_8h_ac55d3781f4c83cba6000c29161e3a419}} 
\index{list.\+h@{list.\+h}!list\+\_\+split\+\_\+at@{list\+\_\+split\+\_\+at}}
\index{list\+\_\+split\+\_\+at@{list\+\_\+split\+\_\+at}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+split\+\_\+at()}
{\footnotesize\ttfamily void list\+\_\+split\+\_\+at (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{list,  }\item[{size\+\_\+t}]{pos,  }\item[{struct \textbf{ list} $\ast$}]{right }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Splits a list in two parts at the position {\ttfamily pos}.

After the split\+: \begin{DoxyItemize}
\item {\ttfamily list} contains nodes in [0, pos[ \item {\ttfamily right} contains nodes in [pos,length(list)[\end{DoxyItemize}
Examples\+: 
\begin{DoxyCode}
list = [1, 2, 3]
list_split_at(list, 0, right) => ([],[1,2,3])
list_split_at(list, 1, right) => ([1],[2,3])
list_split_at(list, 2, right) => ([1,2],[3])
list_split_at(list, 3, right) => ([1,2,3],[])
list = []
list_split_at(list, 0, right) => ([],[])
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em list} & list to split. \\
\hline
{\em pos} & position (0-\/based) where to split the list. \\
\hline
{\em right} & an empty list to receive the part after {\ttfamily pos}\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily list} must be not N\+U\+LL. 

{\ttfamily right} must be not N\+U\+LL. 

{\ttfamily right} must be empty. 

{\ttfamily list} must be different of {\ttfamily right}.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(\+N) 
\end{DoxyRemark}
\mbox{\label{list_8h_a41faf68fcdb7ac3c5d8a9168acd2a331}} 
\index{list.\+h@{list.\+h}!list\+\_\+swap@{list\+\_\+swap}}
\index{list\+\_\+swap@{list\+\_\+swap}!list.\+h@{list.\+h}}
\subsubsection{list\+\_\+swap()}
{\footnotesize\ttfamily void list\+\_\+swap (\begin{DoxyParamCaption}\item[{struct \textbf{ list} $\ast$}]{l1,  }\item[{struct \textbf{ list} $\ast$}]{l2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Swaps two lists.


\begin{DoxyParams}{Parameters}
{\em l1} & list 1. \\
\hline
{\em l2} & list 2.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
{\ttfamily l1} must be not N\+U\+LL. 

{\ttfamily l2} must be not N\+U\+LL. 

{\ttfamily l1} must be different of {\ttfamily l2}.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
Complexity\+: O(1) 
\end{DoxyRemark}
